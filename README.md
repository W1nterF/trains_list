# Найти самый "лучший" путь

# ТЗ:
Дано расписание переездов поездов между несколькими станциями в формате “номер поезда;станция отправления;станция прибытия;стоимость;время отправления;время прибытия” (гарантированно, что нет переездов дольше суток) . Необходимо получить “лучшие” варианты (несколько, если это возможно) проезда между всеми станциями так чтобы побывать на каждой станции 1 раз. 
### Запросы на лучшие варианты: 
+ Лучшие по цене; 
+ Лучшие по времени;

Пример списка:

```no-highlight
907;1909;1929;1790.87;00:50:00;20:00:00
908;1909;1929;1790.87;00:50:00;20:00:00
909;1929;1909;1790.87;10:01:00;01:00:00
909;1929;1921;199.15;11:10:00;01:00:00
910;1929;1909;1790.87;10:01:00;01:00:00
910;1929;1921;199.15;11:10:00;01:00:00
```

# Необходимые библиотеки:

```no-highlight
pip install csv
pip install numpy
pip install itertools
```

# Принцип работы:

1. В самом начале программа открывает .csv файл и создаёт массив отсортированых станций при помощи функции makeStationsList().
Функция сканирует столбцы с номерами станций и записывает в массив лишь те, которые не повторяются.

![Список станций](https://user-images.githubusercontent.com/47121348/174494631-659ddc2c-a46c-4814-a60e-b8b198013820.png)

2. На следующем этапе работы программы создаётся матрица с ценами проезда от одной станции к другой функцией createMatrix().
Для каждой ячейки цена расчитывается индивидуально. За это отвечает функция findMinimalPrice(), которая принимает 2 значения: станцию отправления и станцию прибытия.
После чего она парсит файл и ищет самую дешёвую цену проезда, и возращает её.

> :warning: [!] 0 в таблице означает, что пути на станцию, где которой вы находитесь, не существует.

> :warning: [!] В таблице присутствуют значения 9999. Это значит, что поезда на необходимую станцию нет.
Например: поезда со станции 1902 на станцию 1909 нет.

![image](https://user-images.githubusercontent.com/47121348/174495074-7e179c67-bb32-446e-8050-ea7d17a0bed0.png)

3. На последнем этапе программа ищет "лучший" по цене маршрут *методом полного перебора*.

### Логика работы:
+ Используем 6 вложеных циклов, чтобы перебрать все возможные маршруты.
+ Ищем от 0 до 5.
+ На каждой итерации проверяем, чтобы станции не повторялись, т.к. на каждой можно *побывать только один раз*!
+ Если условие выше выполняется, то запоминаем маршрут и считаем его цену.
+ Если цена маршрута меньше за прошлую, то считаем текущую за минимальную.
+ Проходим все возможные варианты путей. В нашем случае это *6! = 720*.
+ В конце выводим самый дешёвый маршрут и его стоимость.

![image](https://user-images.githubusercontent.com/47121348/174495622-3939f478-4b9d-4eb9-b0bd-e720e3f6d5d0.png)

*На скриншоте видно, как программа перебирает все возможные варианты. Каждый из них индивидуальный и не повторяется!*

![image](https://user-images.githubusercontent.com/47121348/174495451-cd60ddd5-2c30-4b64-87ce-c80bda805040.png)

*На скриншоте выведен самый дешёвый маршрут из всех возможных. Под каждой стрелочкой, указывающей на следущую станцию, написана цена проезда!*

### Функция поиска содержит в себе:
+ Массив для хранения всех просчитаных маршрутов.
+ Порядковый номер текущего маршрута. Каждый новый маршрут будет иметь свой номер.
+ Переменная, в которой хранится самый короткий путь. Чтобы длинну найденого маршруты можно было сравнить с чем-то, в переменную записано число *99999999*. Как только буть дешевле будет найден, заменим его новой минимальной ценой.
+ Номер самого короткого маршрута, чтобы за этим номером потом достать путь из массива.

### Bottleneck программы:

Хоть алгоритм  простой и понятный, но он имеет существенные минусы:
+ При увеличении количества городов у нас возростёт количество вложеных циклов, что сделает код более сложным для понимания.
+ Чем больше будет городов, тем медленнее будет считаться результат. При 10 городах - 3,5 миллиона выполнений тела цикла, при 13 - 6 миллиардов. Чтобы справиться, устройству потребуется огромное количество времени.
